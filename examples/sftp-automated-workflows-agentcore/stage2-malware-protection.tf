################################################################################
# Stage 2: Malware Protection
# Components: GuardDuty Malware Protection, S3 Buckets for Routing
################################################################################

################################################################################
# Random Naming
################################################################################

# Generate random name for malware protection resources
resource "random_pet" "malware" {
  count  = var.enable_malware_protection ? 1 : 0
  prefix = "aws-ia"
  length = 2
}

################################################################################
# Step 1: GuardDuty Malware Protection
################################################################################

# Deploy GuardDuty malware protection with automatic file routing
# This module scans uploaded files and routes them based on scan results
module "guardduty_malware_protection" {
  count  = var.enable_malware_protection ? 1 : 0
  source = "aws-ia/transfer-family/aws//modules/transfer-malware-protection"

  name_prefix = "mp-${random_pet.malware[0].id}"
  # Configure the source bucket to monitor for new file uploads
  s3_ingest_bucket = {
    bucket_name     = local.malware_source_bucket_id
    object_prefixes = [] # Empty list means scan all objects
  }
  
  # KMS key for encrypted buckets (only needed for standalone deployment)
  ingest_bucket_kms_key_arn = local.malware_source_bucket_kms_arn
  
  # SNS topic for threat notifications
  sns_topic_arn_for_threats = aws_sns_topic.malware_threats[0].arn
  
  # Enable dead-letter queue for failed processing
  create_sqs_dlq = true

  # Automatic file routing based on scan results
  # Files are moved to different buckets based on their scan status
  routing_config = {
    "NO_THREATS_FOUND" = module.s3_bucket_clean[0].s3_bucket_id      # Clean files
    "THREATS_FOUND"    = module.s3_bucket_quarantine[0].s3_bucket_id # Infected files
    "UNSUPPORTED"      = module.s3_bucket_errors[0].s3_bucket_id     # Unsupported file types
    "ACCESS_DENIED"    = module.s3_bucket_errors[0].s3_bucket_id     # Permission errors
    "FAILED"           = module.s3_bucket_errors[0].s3_bucket_id     # Scan failures
  }

  tags = var.tags

  depends_on = [
    aws_sns_topic.malware_threats
  ]
}

################################################################################
# Step 2: Source S3 Bucket Configuration
################################################################################

# Reference existing Transfer Server bucket when available
# When Stage 1 is deployed, use the Transfer Family bucket as the scan source
data "aws_s3_bucket" "transfer_source" {
  count  = var.enable_malware_protection && var.enable_transfer_server ? 1 : 0
  bucket = module.s3_bucket_transfer[0].s3_bucket_id
}

# Create standalone source bucket when not using Transfer Server bucket
# This bucket receives files for malware scanning when Stage 1 is not deployed
module "s3_bucket_malware_source" {
  count  = var.enable_malware_protection && !var.enable_transfer_server ? 1 : 0
  source = "git::https://github.com/terraform-aws-modules/terraform-aws-s3-bucket.git?ref=v5.0.0"

  bucket                   = "${random_pet.malware[0].id}-claims-sftp-source"
  force_destroy            = true
  control_object_ownership = true
  object_ownership         = "BucketOwnerEnforced"
  block_public_acls        = true
  block_public_policy      = true
  ignore_public_acls       = true
  restrict_public_buckets  = true

  server_side_encryption_configuration = {
    rule = {
      apply_server_side_encryption_by_default = {
        kms_master_key_id = aws_kms_key.malware_key[0].arn
        sse_algorithm     = "aws:kms"
      }
    }
  }

  versioning = {
    enabled = false
  }

  tags = var.tags
}

# Determine which source bucket to use for malware scanning
# Priority: Transfer Server bucket (Stage 1) > Standalone malware source bucket
locals {
  malware_source_bucket_id      = var.enable_malware_protection ? (var.enable_transfer_server ? data.aws_s3_bucket.transfer_source[0].id : module.s3_bucket_malware_source[0].s3_bucket_id) : null
  malware_source_bucket_kms_arn = var.enable_malware_protection ? (var.enable_transfer_server ? null : aws_kms_key.malware_key[0].arn) : null
}

################################################################################
# Step 3: Routing S3 Buckets
################################################################################

# Create bucket for clean files (passed malware scan)
# Files that pass GuardDuty malware scanning are automatically moved here
module "s3_bucket_clean" {
  count  = var.enable_malware_protection ? 1 : 0
  source = "git::https://github.com/terraform-aws-modules/terraform-aws-s3-bucket.git?ref=v5.0.0"

  bucket                   = "${random_pet.malware[0].id}-claims-clean"
  force_destroy            = true
  control_object_ownership = true
  object_ownership         = "BucketOwnerEnforced"
  block_public_acls        = true
  block_public_policy      = true
  ignore_public_acls       = true
  restrict_public_buckets  = true

  server_side_encryption_configuration = {
    rule = {
      apply_server_side_encryption_by_default = {
        sse_algorithm = "AES256"
      }
    }
  }

  versioning = {
    enabled = false
  }

  tags = var.tags
}

# Create bucket for quarantined files (failed malware scan)
# Files with detected threats are automatically moved here for isolation
module "s3_bucket_quarantine" {
  count  = var.enable_malware_protection ? 1 : 0
  source = "git::https://github.com/terraform-aws-modules/terraform-aws-s3-bucket.git?ref=v5.0.0"

  bucket                   = "${random_pet.malware[0].id}-claims-quarantine"
  force_destroy            = true
  control_object_ownership = true
  object_ownership         = "BucketOwnerEnforced"
  block_public_acls        = true
  block_public_policy      = true
  ignore_public_acls       = true
  restrict_public_buckets  = true

  server_side_encryption_configuration = {
    rule = {
      apply_server_side_encryption_by_default = {
        sse_algorithm = "AES256"
      }
    }
  }

  versioning = {
    enabled = false
  }

  tags = var.tags
}

# Create bucket for scan errors (unsupported files, access denied, etc.)
# Files that cannot be scanned are moved here for manual review
module "s3_bucket_errors" {
  count  = var.enable_malware_protection ? 1 : 0
  source = "git::https://github.com/terraform-aws-modules/terraform-aws-s3-bucket.git?ref=v5.0.0"

  bucket                   = "${random_pet.malware[0].id}-claims-errors"
  force_destroy            = true
  control_object_ownership = true
  object_ownership         = "BucketOwnerEnforced"
  block_public_acls        = true
  block_public_policy      = true
  ignore_public_acls       = true
  restrict_public_buckets  = true

  server_side_encryption_configuration = {
    rule = {
      apply_server_side_encryption_by_default = {
        sse_algorithm = "AES256"
      }
    }
  }

  versioning = {
    enabled = false
  }

  tags = var.tags
}

################################################################################
# Step 4: SNS Topic for Threat Notifications
################################################################################

# Create SNS topic for malware threat alerts
# Notifications are sent here when threats are detected
resource "aws_sns_topic" "malware_threats" {
  count = var.enable_malware_protection ? 1 : 0

  name              = "${random_pet.malware[0].id}-malware-sns-topic"
  kms_master_key_id = "alias/aws/sns"

  tags = var.tags
}

################################################################################
# Step 5: KMS Encryption (for standalone deployment)
################################################################################

# Create KMS key for S3 bucket encryption when not using existing Transfer bucket
# This is only needed when deploying malware protection without Stage 1
resource "aws_kms_key" "malware_key" {
  count = var.enable_malware_protection && !var.enable_transfer_server ? 1 : 0

  description             = "KMS key for encrypting S3 bucket and cloudwatch log group"
  deletion_window_in_days = 7
  enable_key_rotation     = true

  tags = var.tags
}

# Create alias for KMS key
resource "aws_kms_alias" "malware_key_alias" {
  count = var.enable_malware_protection && !var.enable_transfer_server ? 1 : 0

  name          = "alias/transfer-family-key-${random_pet.malware[0].id}"
  target_key_id = aws_kms_key.malware_key[0].key_id
}

# Configure KMS key policy for CloudWatch Logs access
resource "aws_kms_key_policy" "malware_key_policy" {
  count = var.enable_malware_protection && !var.enable_transfer_server ? 1 : 0

  key_id = aws_kms_key.malware_key[0].id
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "Enable Limited Admin Permissions"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:root"
        }
        Action   = "kms:*"
        Resource = aws_kms_key.malware_key[0].arn
      },
      {
        Sid    = "Allow CloudWatch Logs"
        Effect = "Allow"
        Principal = {
          Service = "logs.${var.aws_region}.amazonaws.com"
        }
        Action = [
          "kms:Encrypt",
          "kms:Decrypt",
          "kms:ReEncrypt*",
          "kms:GenerateDataKey*",
          "kms:CreateGrant",
          "kms:Describe*"
        ]
        Resource = aws_kms_key.malware_key[0].arn
        Condition = {
          ArnEquals = {
            "kms:EncryptionContext:aws:logs:arn" = "arn:aws:logs:${var.aws_region}:${data.aws_caller_identity.current.account_id}:*"
          }
        }
      }
    ]
  })
}

################################################################################
# Step 6: Cleanup Resources
################################################################################

# Remove validation object on destroy to prevent deletion errors
# The malware protection module creates a validation object that must be removed
# before the bucket can be destroyed
resource "null_resource" "cleanup_validation_object" {
  count = var.enable_malware_protection ? 1 : 0

  depends_on = [module.guardduty_malware_protection]

  triggers = {
    bucket_name = local.malware_source_bucket_id
  }

  provisioner "local-exec" {
    when    = destroy
    command = <<-EOT
      aws s3api delete-objects --bucket ${self.triggers.bucket_name} --delete "$(aws s3api list-object-versions --bucket ${self.triggers.bucket_name} --prefix malware-protection-resource-validation-object --query '{Objects: [Versions[].{Key:Key,VersionId:VersionId}, DeleteMarkers[].{Key:Key,VersionId:VersionId}] | [0]}' --output json)" || true
    EOT
  }
}
