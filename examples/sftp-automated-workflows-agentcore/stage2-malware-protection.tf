################################################################################
# Stage 2: Malware Protection
# Components: GuardDuty Malware Protection, S3 Buckets for Routing
################################################################################

################################################################################
# Random Naming
################################################################################

# Generate random name for malware protection resources
resource "random_pet" "malware" {
  count  = var.enable_malware_protection ? 1 : 0
  prefix = "aws-ia"
  length = 2
}

################################################################################
# KMS Encryption (for standalone deployment without Transfer Server)
################################################################################

# Create KMS key for S3 bucket encryption when not using existing Transfer bucket
resource "aws_kms_key" "malware_key" {
  count = var.enable_malware_protection && !var.enable_transfer_server ? 1 : 0

  description             = "KMS key for encrypting S3 bucket and cloudwatch log group"
  deletion_window_in_days = 7
  enable_key_rotation     = true

  tags = var.tags
}

# Create alias for KMS key
resource "aws_kms_alias" "malware_key_alias" {
  count = var.enable_malware_protection && !var.enable_transfer_server ? 1 : 0

  name          = "alias/transfer-family-key-${random_pet.malware[0].id}"
  target_key_id = aws_kms_key.malware_key[0].key_id
}

# Configure KMS key policy for CloudWatch Logs access
resource "aws_kms_key_policy" "malware_key_policy" {
  count = var.enable_malware_protection && !var.enable_transfer_server ? 1 : 0

  key_id = aws_kms_key.malware_key[0].id
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "Enable Limited Admin Permissions"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:root"
        }
        Action   = "kms:*"
        Resource = aws_kms_key.malware_key[0].arn
      },
      {
        Sid    = "Allow CloudWatch Logs"
        Effect = "Allow"
        Principal = {
          Service = "logs.${var.aws_region}.amazonaws.com"
        }
        Action = [
          "kms:Encrypt",
          "kms:Decrypt",
          "kms:ReEncrypt*",
          "kms:GenerateDataKey*",
          "kms:CreateGrant",
          "kms:Describe*"
        ]
        Resource = aws_kms_key.malware_key[0].arn
        Condition = {
          ArnEquals = {
            "kms:EncryptionContext:aws:logs:arn" = "arn:aws:logs:${var.aws_region}:${data.aws_caller_identity.current.account_id}:*"
          }
        }
      }
    ]
  })
}

################################################################################
# Source S3 Bucket (for standalone deployment)
################################################################################

# Create standalone source bucket when not using Transfer Server bucket
module "s3_bucket_malware_source" {
  count  = var.enable_malware_protection && !var.enable_transfer_server ? 1 : 0
  source = "git::https://github.com/terraform-aws-modules/terraform-aws-s3-bucket.git?ref=v5.0.0"

  bucket                   = "${random_pet.malware[0].id}-claims-sftp-source"
  control_object_ownership = true
  object_ownership         = "BucketOwnerEnforced"
  block_public_acls        = true
  block_public_policy      = true
  ignore_public_acls       = true
  restrict_public_buckets  = true

  server_side_encryption_configuration = {
    rule = {
      apply_server_side_encryption_by_default = {
        kms_master_key_id = aws_kms_key.malware_key[0].arn
        sse_algorithm     = "aws:kms"
      }
    }
  }

  versioning = {
    enabled = false
  }

  tags = var.tags
}

# Reference existing Transfer Server bucket when available
data "aws_s3_bucket" "transfer_source" {
  count  = var.enable_malware_protection && var.enable_transfer_server ? 1 : 0
  bucket = module.s3_bucket_transfer[0].s3_bucket_id
}

# Determine which source bucket to use for malware scanning
locals {
  malware_source_bucket_id      = var.enable_malware_protection ? (var.enable_transfer_server ? data.aws_s3_bucket.transfer_source[0].id : module.s3_bucket_malware_source[0].s3_bucket_id) : null
  malware_source_bucket_kms_arn = var.enable_malware_protection ? (var.enable_transfer_server ? null : aws_kms_key.malware_key[0].arn) : null
}

################################################################################
# Routing S3 Buckets
################################################################################

# Create bucket for clean files (passed malware scan)
module "s3_bucket_clean" {
  count  = var.enable_malware_protection ? 1 : 0
  source = "git::https://github.com/terraform-aws-modules/terraform-aws-s3-bucket.git?ref=v5.0.0"

  bucket                   = "${random_pet.malware[0].id}-claims-clean"
  control_object_ownership = true
  object_ownership         = "BucketOwnerEnforced"
  block_public_acls        = true
  block_public_policy      = true
  ignore_public_acls       = true
  restrict_public_buckets  = true

  server_side_encryption_configuration = {
    rule = {
      apply_server_side_encryption_by_default = {
        sse_algorithm = "AES256"
      }
    }
  }

  versioning = {
    enabled = false
  }

  tags = var.tags
}

# Create bucket for quarantined files (failed malware scan)
module "s3_bucket_quarantine" {
  count  = var.enable_malware_protection ? 1 : 0
  source = "git::https://github.com/terraform-aws-modules/terraform-aws-s3-bucket.git?ref=v5.0.0"

  bucket                   = "${random_pet.malware[0].id}-claims-quarantine"
  control_object_ownership = true
  object_ownership         = "BucketOwnerEnforced"
  block_public_acls        = true
  block_public_policy      = true
  ignore_public_acls       = true
  restrict_public_buckets  = true

  server_side_encryption_configuration = {
    rule = {
      apply_server_side_encryption_by_default = {
        sse_algorithm = "AES256"
      }
    }
  }

  versioning = {
    enabled = false
  }

  tags = var.tags
}

# Create bucket for scan errors (unsupported files, access denied, etc.)
module "s3_bucket_errors" {
  count  = var.enable_malware_protection ? 1 : 0
  source = "git::https://github.com/terraform-aws-modules/terraform-aws-s3-bucket.git?ref=v5.0.0"

  bucket                   = "${random_pet.malware[0].id}-claims-errors"
  control_object_ownership = true
  object_ownership         = "BucketOwnerEnforced"
  block_public_acls        = true
  block_public_policy      = true
  ignore_public_acls       = true
  restrict_public_buckets  = true

  server_side_encryption_configuration = {
    rule = {
      apply_server_side_encryption_by_default = {
        sse_algorithm = "AES256"
      }
    }
  }

  versioning = {
    enabled = false
  }

  tags = var.tags
}

################################################################################
# SNS Topic for Threat Notifications
################################################################################

# Create SNS topic for malware threat alerts
resource "aws_sns_topic" "malware_threats" {
  count = var.enable_malware_protection ? 1 : 0

  name              = "${random_pet.malware[0].id}-malware-sns-topic"
  kms_master_key_id = "alias/aws/sns"

  tags = var.tags
}

################################################################################
# GuardDuty Malware Protection
################################################################################

# Deploy GuardDuty malware protection with automatic file routing
module "guardduty_malware_protection" {
  count  = var.enable_malware_protection ? 1 : 0
  source = "aws-ia/transfer-family/aws//modules/transfer-malware-protection"

  name_prefix = "mp-${random_pet.malware[0].id}"
  s3_ingest_bucket = {
    bucket_name     = local.malware_source_bucket_id
    object_prefixes = []
  }
  ingest_bucket_kms_key_arn = local.malware_source_bucket_kms_arn
  sns_topic_arn_for_threats = aws_sns_topic.malware_threats[0].arn
  tags                      = var.tags
  create_sqs_dlq            = true

  routing_config = {
    "NO_THREATS_FOUND" = module.s3_bucket_clean[0].s3_bucket_id
    "THREATS_FOUND"    = module.s3_bucket_quarantine[0].s3_bucket_id
    "UNSUPPORTED"      = module.s3_bucket_errors[0].s3_bucket_id
    "ACCESS_DENIED"    = module.s3_bucket_errors[0].s3_bucket_id
    "FAILED"           = module.s3_bucket_errors[0].s3_bucket_id
  }

  depends_on = [
    aws_sns_topic.malware_threats
  ]
}

################################################################################
# Cleanup Resources
################################################################################

# Remove validation object on destroy to prevent deletion errors
resource "null_resource" "cleanup_validation_object" {
  count = var.enable_malware_protection ? 1 : 0

  depends_on = [module.guardduty_malware_protection]

  triggers = {
    bucket_name = local.malware_source_bucket_id
  }

  provisioner "local-exec" {
    when    = destroy
    command = <<-EOT
      aws s3api delete-objects --bucket ${self.triggers.bucket_name} --delete "$(aws s3api list-object-versions --bucket ${self.triggers.bucket_name} --prefix malware-protection-resource-validation-object --query '{Objects: [Versions[].{Key:Key,VersionId:VersionId}, DeleteMarkers[].{Key:Key,VersionId:VersionId}] | [0]}' --output json)" || true
    EOT
  }
}
